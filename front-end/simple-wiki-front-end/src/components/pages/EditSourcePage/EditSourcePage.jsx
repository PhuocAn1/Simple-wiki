import { useEffect, useRef, useState } from 'react';
import { Link, useParams, useLocation} from 'react-router-dom';
import { FaLink, FaImage, FaBold, FaItalic } from 'react-icons/fa';
import { FaBookBookmark } from "react-icons/fa6";
import Header from '../../common/Header/Header';
import { renderWikiText } from '../../services/WikiMarkupService';
import { getPageContentByTitle, createPage, getRawWikitextContentByTitle, updatePage } from '../../services/PageService';
import ConfirmationPanel from '../../common/ConfirmationPanel/ConfirmationPanel';
import { useAuth, getStoredItem } from '../../context/AuthContext';
import InsertFilePanel from '../../common/InsertFilePanel/InsertFilePanel';
import styles from './EditSourcePage.module.css'

const EditSourcePage = () => {
    const location = useLocation();
    const [content, setContent] = useState(''); // This is the raw wikitext
    const [previewContent, setPreviewContent] = useState(''); // State to hold rendered HTML
    const [showPreview, setShowPreview] = useState(false); // Toggle preview panel
    const [summary, setSummary] = useState('');
    const [showConfirm, setShowConfirm] = useState(false)// State use by the Confirmation panel
    const [showInsertFilePanel, setInsertFilePanel] = useState(false)

    // Getting and setting the page title
    const { pageTitle: routeTitle } = useParams(); // get from URL
    const [pageTitle, setPageTitle] = useState("");

    const {isLoggedIn} = useAuth();

    useEffect(() => {
        if (routeTitle) {
            setPageTitle(decodeURIComponent(routeTitle).replace(/_/g, ' '));
        }
        fetchRawWikiText(decodeURIComponent(routeTitle).replace(/_/g, ' '));
    }, [routeTitle]);

    const fetchRawWikiText = async (title) => {
      try {
        const pageDTO = await getRawWikitextContentByTitle(title);
        //console.log(pageDTO.pageRevisionDTO.content);
        const rawContent = pageDTO.pageRevisionDTO.content;
        setContent(rawContent);

        return rawContent
      } catch (error) {
        console.log(error.message);
        return null;
      }
    }

    // Function to parse and render wikitext (simplified)
    const renderPreview = async (rawText) => {
        if (content !== '') {
            try {
                const htmlContent = await renderWikiText(rawText);
                setPreviewContent(htmlContent); // Update state with rendered HTML
            } catch (error) {
                console.error('Error rendering preview:', error);
                setPreviewContent('<p>Error rendering content</p>'); // Fallback for errors
            }
        } else {
            setPreviewContent(''); // Clear preview if content is empty
        }
    };


    const handleContentChange = (e) => {
        setContent(e.target.value);
    };

    const handleSummaryChange = (e) => {
        setSummary(e.target.value);
    };

    const previewButtonClicked = () => {
        setShowPreview(!showPreview);
        if (!showPreview) {
            renderPreview(content); // Render preview when showing it
        }
    };

    const reloadButtonClicked = () => {
        if (showPreview) {
            renderPreview(content); // Re-render preview on reload
        }
    };

    const cancleButtonClicked = () => {
        setShowConfirm(true);
    }

    const saveButtonClicked = async () => {
        // Check if a page has existed with the page title if not then create a page, otherwise update the page.
        let isPageExisted = true; // This check if we need to create a new page or to simply update the existing page.

        // 1.Check if a page with the provided title has existed or not
        try {
            await getPageContentByTitle(pageTitle);
        } catch (error) {
            isPageExisted = false;
            console.log(error.message);
        }

        const userId = parseInt(getStoredItem('userId')); // Get the userId
        if (isNaN(userId)) {
            console.error('Invalid userId from localStorage or sessionStorage');
            alert('Invalid userId from localStorage or sessionStorage');
            return;
        }

        // 2.Constructing the pageDTO to pass to the backend
        const pageDTO = {
            pageId: null, // Will be auto-generated by the backend
            title: pageTitle, // The user page title will follow the convention "User:" + username
            userId: userId, 
            pageRevisionDTO: {
                revisionId: null, // Will be auto-generated by the backend
                pageId: null, // Will be set by the backend
                userId: userId,
                content: content || '', // Use empty string if no content
                summary: summary || '', // Use empty string if no summary
                createdAt: new Date().toISOString(), // Match LocalDateTime format
            },
            createdAt: new Date().toISOString(), // Match LocalDateTime format
            updatedAt: new Date().toISOString(), // Match LocalDateTime format
        };

        console.log(pageDTO);
        // 3.Update or create a page
        if (isPageExisted === false) {
            // The page for the user has not been created yet so we create a page here
            console.log("Creating page!");
            try {
                const response = await createPage(pageDTO);
                console.log('Page created successfully:', response);
                alert("Page created successfully!")
                // May be navigate back to the user page after this?
            } catch (error) {
                console.error('Error creating page:', error.message);
                alert('Error creating page:', error.message);
                // Optionally add UI feedback for the error
            }

        } else {
            // Updated the page
            console.log("Updating page");
            try {
                const response = await updatePage(pageDTO, pageTitle);
                console.log('Page updated successfully:', response);
                alert("Page updated successfully!");
            } catch (error) {
                console.error('Error updating page:', error.message);
                alert('Error updating page:', error.message);
            }
        }
    }

    const handleDiscard = async () => {
        // Logic to discard edits
        console.log("Edits discarded");
        setShowConfirm(false);
        // Re fetch raw wiki text
        const rawText = await fetchRawWikiText(pageTitle); // await will allow the fecth to be complete before calling renderPreview()
        // Render the preview if it is display
        if (showPreview && rawText != null) {
            renderPreview(rawText);
        } 
    }

    const handleCancel = () => {
        // This is the continue editing option for the cancel edit option
        setShowConfirm(false);
    }

    const showPreviewClicked = async () => {
        let pageContent = ""; // The preview html content for preview page
        try {
            pageContent = await renderWikiText(content);
        } catch (error) {
            pageContent = "<p>Error rendering content</p>";
        }
        // Store pageTitle and pageContent in sessionStorage
        sessionStorage.setItem('previewData', JSON.stringify({ pageTitle, pageContent }));
        // Open a new tab with the preview route
        window.open('/preview', '_blank');
    }

    // This section will handle the editor toolbar button like insert link, reference, ...
    const textAreaRef = useRef(null);

    const insertReference = () => {
        const textarea = textAreaRef.current;
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const selectedText = content.slice(start, end);

        const before = content.slice(0, start);
        const after = content.slice(end);

        let newContent, cursorPos;
        if (selectedText) {
            const wrapped = `<ref>${selectedText}</ref>`;
            newContent = before + wrapped + after;
            cursorPos = start + wrapped.length; // ðŸ”¸ cursor after closing tag
        } else {
            const emptyRef = `<ref></ref>`;
            newContent = before + emptyRef + after;
            cursorPos = start + 5; // ðŸ”¹ cursor inside empty tag: <ref>|</ref>
        }

        setContent(newContent);

        // Optionally place cursor after the closing tag
        setTimeout(() => {
            textarea.focus();
            textarea.setSelectionRange(cursorPos, cursorPos);
        }, 0);
    }

    // Bold and italic
    const insertBold = () => {
        const textarea = textAreaRef.current;
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const selected = content.slice(start, end);
        const before = content.slice(0, start);
        const after = content.slice(end);

        textarea.focus();
        try {
            if (selected) {
                // For selected text
                const wrapped = `'''${selected}'''`;
                document.execCommand('insertText', false, wrapped);

                setTimeout(() => {
                    const newPos = start + wrapped.length;
                    textarea.focus();
                    textarea.setSelectionRange(newPos, newPos);
                }, 0);
            } else {
                // For empty selection
                const placeholder = 'bold text';
                const wrapped = `'''${placeholder}'''`;

                document.execCommand('insertText', false, wrapped);
                
                setTimeout(() => {
                    const highlightStart = start + 3; // after opening quotes
                    const highlightEnd = highlightStart + placeholder.length;
                    textarea.focus();
                    textarea.setSelectionRange(highlightStart, highlightEnd);
                }, 0);
            }
        } catch (error) {
            console.log("document.execCommand is not supported, fall back to original insert bold method");
            if (selected) {
                const wrapped = `''${selected}''`;
                setContent(before + wrapped + after);
            
                // Set the cursor postion just after the closing formatting tag
                setTimeout(() => {
                    const newPos = start + wrapped.length;
                    textarea.focus();
                    textarea.setSelectionRange(newPos, newPos);
                }, 0);
            } else {    
                const placeholder = 'bold text';
                const wrapped = `'''${placeholder}'''`;
                setContent(before + wrapped + after);

                setTimeout(() => {
                    const highlightStart = start + 3; // after opening quotes
                    const highlightEnd = highlightStart + placeholder.length;
                    textarea.focus();
                    textarea.setSelectionRange(highlightStart, highlightEnd);
                }, 0);
            }
        }       
    };

    const insertItalic = () => {
        const textarea = textAreaRef.current;
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const selected = content.slice(start, end);
        const before = content.slice(0, start);
        const after = content.slice(end);

        textarea.focus();
        try {
            if (selected) {
                // For selected text
                const wrapped = `''${selected}''`;
                document.execCommand('insertText', false, wrapped);

                setTimeout(() => {
                    const newPos = start + wrapped.length;
                    textarea.focus();
                    textarea.setSelectionRange(newPos, newPos);
                }, 0);
            } else {
                // For empty selection
                const placeholder = 'italic text';
                const wrapped = `''${placeholder}''`;
                document.execCommand('insertText', false, wrapped);

                setTimeout(() => {
                    const highlightStart = start + 2; // after opening quotes
                    const highlightEnd = highlightStart + placeholder.length;
                    textarea.focus();
                    textarea.setSelectionRange(highlightStart, highlightEnd);
                }, 0);
            }
        } catch (error) {
            console.log("document.execCommand is not supported, fall back to original insert Italic method");
            if (selected) {
                const wrapped = `''${selected}''`;
                setContent(before + wrapped + after);

                setTimeout(() => {
                    const newPos = start + wrapped.length;
                    textarea.focus();
                    textarea.setSelectionRange(newPos, newPos);
                }, 0);      
            } else {
                const placeholder = 'italic text';
                const wrapped = `''${placeholder}''`;
                setContent(before + wrapped + after);

                setTimeout(() => {
                    const highlightStart = start + 2; // after opening quotes
                    const highlightEnd = highlightStart + placeholder.length;
                    textarea.focus();
                    textarea.setSelectionRange(highlightStart, highlightEnd);
                }, 0);
            }   
        }
        
    };

    // Link
    const insertLink = () => {
        const textarea = textAreaRef.current;
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const selected = content.slice(start, end);
        const before = content.slice(0, start);
        const after = content.slice(end);

        textarea.focus();
        try {
            if (selected) {
                // For selected text
                const wrapped = `[[${selected}]]`;
                document.execCommand('insertText', false, wrapped);
                //setContent(textarea.value); // Ensure the content use sate is update

                setTimeout(() => {
                    const newPos = start + wrapped.length;
                    textarea.focus();
                    textarea.setSelectionRange(newPos, newPos);
                }, 0);
            } else {
                // For empty selection
                const placeholder = '[[]]';
                const wrapped = `[[]]`;
                document.execCommand('insertText', false, wrapped);
                //setContent(textarea.value);

                setTimeout(() => {
                    const newPos = start + 2;
                    textarea.focus();
                    textarea.setSelectionRange(newPos, newPos);
                }, 0);
            }
        } catch (error) {
            console.log("document.execCommand is not supported, fall back to original insert Link method");
            if (selected) {
                // For selected text
                const wrapped = `[[${selected}]]`;
                setContent(before + wrapped + after);

                setTimeout(() => {
                    const newPos = start + wrapped.length;
                    textarea.focus();
                    textarea.setSelectionRange(newPos, newPos);
                }, 0);   
            } else {
                // For empty selection
                const placeholder = '[[]]';
                const wrapped = `[[]]`;
                setContent(before + wrapped + after);

                setTimeout(() => {
                    const newPos = 2;
                    textarea.focus();
                    textarea.setSelectionRange(newPos, newPos);
                }, 0);
            }
        }
    }

    // Images and media
    const imageAndMediaButtonCliced = () => {
        setInsertFilePanel(true);
        console.log("Show insert file panel: ", showInsertFilePanel);
    }

    const insertFileOnClose = (wikitext) => {
        setInsertFilePanel(false); // Close the panel
        if (wikitext === "") {
            return;
        }
        
        if (wikitext && textAreaRef.current) {
            const textarea = textAreaRef.current;
            const startPos = textarea.selectionStart; // Get cursor start position
            const endPos = textarea.selectionEnd; // Get cursor end position
            const newContent =
            content.substring(0, startPos) + // Text before cursor
            wikitext + // Inserted wikitext
            content.substring(endPos); // Text after cursor
            setContent(newContent); // Update textarea content
        }
    }

    const onUploadNavigate = () => {
        window.open('/upload', '_blank');
    }
    //----------------------------------------------------------------------------------

    return (
        <div className="wiki-container">
            <Header />
            <div className="subheader">
                <Link to={`/pages/${encodeURIComponent(pageTitle)}`} className="subheader-link">Page</Link>
                <Link to={``} className="subheader-link active">Edit source</Link>
            </div>

            <div className="page-content">
                <h1 className='page-title'>Editing {pageTitle}</h1>

                {!isLoggedIn && (
                    <div className={styles.permissionMessage}>
                        <p><strong>You do not have permission to edit this page, for the following reason:</strong></p>
                        <p>The action you have requested is limited to users in the group: <strong>Users</strong>.</p>
                        <p>You can view and copy the source of this page. If you believe you should be able to edit this page, you may need to:</p>
                        <ul>
                            <li><Link to="/login" state={{ from: location }}>Log in</Link></li>
                            <li>
                            Request Administrator rights on this wiki. Please do this by contacting a
                            <a href="/local-admin"> local admin</a> or, if your wiki has no active admins,
                            <a href="/submit-ticket"> submitting a ticket</a>.
                            </li>
                        </ul>
                    </div>
                )}

                <div className="editor-toolbar-container">
                    {isLoggedIn ? (
                        <div className="editor-toolbar">
                            <button title='Bold' onClick={insertBold}><FaBold /></button>
                            <button title='Italic' onClick={insertItalic}><FaItalic /></button>
                            <button title='Link' onClick={insertLink}><FaLink /></button>
                            <button title='Image and media' onClick={imageAndMediaButtonCliced}><FaImage /></button>
                            <button title='Reference' onClick={insertReference}><FaBookBookmark /></button>
                        </div>
                    ) : (
                        <div className="editor-toolbar" style={{ visibility: 'hidden' }}></div>
                    )}



                    <div className="editor-toolbar-right-button-group">
                        <button className={`reload-button ${showPreview ? 'visible' : ''}`} 
                        onClick={reloadButtonClicked}>
                            Reload
                        </button>

                        <button className="preview-button" onClick={previewButtonClicked}>
                            {showPreview ? 'Hide Preview' : 'Preview'}
                        </button> 
                    </div>
                </div>

                <div className="editor-container">
                    <textarea
                    ref={textAreaRef}
                    value={content}
                    onChange={handleContentChange}
                    placeholder="Testing wikitext..."
                    className="editor-textarea"
                    disabled={!isLoggedIn} // disables for non-logged-in users
                    style={{ width: showPreview ? '50%' : '100%' }}
                    />

                    {showPreview && (
                        <div className="preview-pane">
                            <div className="preview-content" dangerouslySetInnerHTML={{ __html: previewContent }}></div>
                        </div>
                    )}
                </div>

                {isLoggedIn && (
                    <div className="edit-options">
                        <span className="edit-summary"><label htmlFor="">Summary: </label></span>
                        <input
                        value={summary}
                        onChange={handleSummaryChange}
                        className="summary-textarea"
                        />

                        <div className="edit-buttons">
                            <button className="save-button" onClick={saveButtonClicked}>Save</button> 
                            <button className="show-preview-button" onClick={showPreviewClicked}>Show preview</button>
                            <button className="cancel-button" onClick={cancleButtonClicked}>Cancel</button>
                        </div>

                        {showConfirm && (
                            <ConfirmationPanel
                            message="Are you sure you want to leave editing mode without publishing first?"
                            onConfirm={handleDiscard}
                            onCancel={handleCancel}
                        />
                        )}

                        {showInsertFilePanel &&(
                            <InsertFilePanel onClose={insertFileOnClose} onUploadNavigate={onUploadNavigate}/>
                        )}
                    </div>
                )}    
                
            </div>

        </div>
    );
}

export default EditSourcePage;